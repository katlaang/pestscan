package mofo.com.pestscout.analytics.service;

import lombok.RequiredArgsConstructor;
import mofo.com.pestscout.analytics.dto.*;
import mofo.com.pestscout.common.exception.ResourceNotFoundException;
import mofo.com.pestscout.farm.model.Farm;
import mofo.com.pestscout.farm.repository.FarmRepository;
import mofo.com.pestscout.farm.service.AnalyticsService;
import mofo.com.pestscout.scouting.dto.ScoutingSessionDetailDto;
import mofo.com.pestscout.scouting.model.ScoutingSession;
import mofo.com.pestscout.scouting.repository.ScoutingSessionRepository;
import mofo.com.pestscout.scouting.service.ScoutingSessionService;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.temporal.WeekFields;
import java.util.List;
import java.util.Locale;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class ReportingService {

    private final FarmRepository farmRepository;
    private final ScoutingSessionRepository sessionRepository;
    private final HeatmapService heatmapService;
    private final AnalyticsService analyticsService;
    private final ScoutingSessionService scoutingSessionService;

    /**
     * Full report for a single session.
     */
    @Transactional(readOnly = true)
    public ScoutingSessionDetailDto getSessionReport(UUID sessionId) {
        return scoutingSessionService.getSession(sessionId);
    }

    /**
     * Weekly report for a farm:
     * - sessions in the week
     * - weekly heatmap
     * - analytics summary
     */
    @Transactional(readOnly = true)
    public WeeklyFarmReportDto getWeeklyFarmReport(UUID farmId, int week, int year) {
        Farm farm = farmRepository.findById(farmId)
                .orElseThrow(() -> new ResourceNotFoundException("Farm", "id", farmId));

        WeekFields weekFields = WeekFields.of(Locale.getDefault());
        LocalDate firstWeekReference = LocalDate.of(year, 1, 4);

        LocalDate weekStart = firstWeekReference
                .with(weekFields.weekOfWeekBasedYear(), week)
                .with(weekFields.dayOfWeek(), 1);

        LocalDate weekEnd = weekStart.plusDays(6);

        List<ScoutingSession> sessions = sessionRepository
                .findByFarmIdAndSessionDateBetween(farmId, weekStart, weekEnd);

        List<ScoutingSessionDetailDto> sessionDtos = sessions.stream()
                .map(s -> scoutingSessionService.getSession(s.getId()))
                .toList();

        HeatmapResponse heatmap = heatmapService.generateHeatmap(farmId, week, year);
        FarmWeeklyAnalyticsDto analytics = analyticsService.computeWeeklyAnalytics(farmId, week, year);

        return new WeeklyFarmReportDto(
                farm.getId(),
                farm.getName(),
                week,
                year,
                weekStart,
                weekEnd,
                sessionDtos,
                heatmap,
                analytics
        );
    }

    /**
     * Wrapper DTO for the weekly report.
     * This is a nested record, so outside callers must use:
     *   ReportingService.WeeklyFarmReportDto
     */
    public record WeeklyFarmReportDto(
            UUID farmId,
            String farmName,
            int week,
            int year,
            LocalDate weekStart,
            LocalDate weekEnd,
            List<ScoutingSessionDetailDto> sessions,
            HeatmapResponse heatmap,
            FarmWeeklyAnalyticsDto analytics
    ) {
    }

    // --------------------------------------------------------------------
    // Additional methods needed by dashboard / reporting (SAFE STUBS)
    // You can fill these with real logic later.
    // --------------------------------------------------------------------

    /**
     * Monthly report composed of weekly heatmaps + trends + analytics.
     * Currently returns null as a placeholder to avoid compilation errors.
     */
    @Transactional(readOnly = true)
    public FarmMonthlyReportDto getMonthlyReport(UUID farmId, int year, int month) {
        // TODO: implement monthly aggregation logic
        return null;
    }

    /**
     * Recommendations generated by scouting sessions.
     * Currently returns an empty list placeholder.
     */
    @Transactional(readOnly = true)
    public List<RecommendationDto> getRecommendations(UUID farmId) {
        // TODO: implement once recommendation entities / fields are final
        return List.of();
    }

    /**
     * Active alerts for a farm.
     * Currently returns an empty list placeholder.
     */
    @Transactional(readOnly = true)
    public List<AlertDto> getAlerts(UUID farmId) {
        // TODO: implement once alert logic is finalized
        return List.of();
    }

    /**
     * Compares farms based on severity and observation counts.
     * Currently returns an empty list placeholder.
     */
    @Transactional(readOnly = true)
    public List<FarmComparisonDto> getFarmComparison() {
        // TODO: implement farm comparison when metrics are finalized
        return List.of();
    }

    /**
     * Aggregated scout performance.
     * Currently returns an empty list placeholder.
     */
    @Transactional(readOnly = true)
    public List<ScoutPerformanceDto> getScoutPerformance(UUID farmId) {
        // TODO: implement real performance metrics later
        return List.of();
    }
}
